// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  commentaire: (where?: CommentaireWhereInput) => Promise<boolean>;
  emprunts: (where?: EmpruntsWhereInput) => Promise<boolean>;
  livre: (where?: LivreWhereInput) => Promise<boolean>;
  utilisateur: (where?: UtilisateurWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  commentaire: (
    where: CommentaireWhereUniqueInput
  ) => CommentaireNullablePromise;
  commentaires: (args?: {
    where?: CommentaireWhereInput;
    orderBy?: CommentaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Commentaire>;
  commentairesConnection: (args?: {
    where?: CommentaireWhereInput;
    orderBy?: CommentaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentaireConnectionPromise;
  emprunts: (where: EmpruntsWhereUniqueInput) => EmpruntsNullablePromise;
  empruntses: (args?: {
    where?: EmpruntsWhereInput;
    orderBy?: EmpruntsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Emprunts>;
  empruntsesConnection: (args?: {
    where?: EmpruntsWhereInput;
    orderBy?: EmpruntsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmpruntsConnectionPromise;
  livre: (where: LivreWhereUniqueInput) => LivreNullablePromise;
  livres: (args?: {
    where?: LivreWhereInput;
    orderBy?: LivreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Livre>;
  livresConnection: (args?: {
    where?: LivreWhereInput;
    orderBy?: LivreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LivreConnectionPromise;
  utilisateur: (
    where: UtilisateurWhereUniqueInput
  ) => UtilisateurNullablePromise;
  utilisateurs: (args?: {
    where?: UtilisateurWhereInput;
    orderBy?: UtilisateurOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Utilisateur>;
  utilisateursConnection: (args?: {
    where?: UtilisateurWhereInput;
    orderBy?: UtilisateurOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UtilisateurConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCommentaire: (data: CommentaireCreateInput) => CommentairePromise;
  updateCommentaire: (args: {
    data: CommentaireUpdateInput;
    where: CommentaireWhereUniqueInput;
  }) => CommentairePromise;
  updateManyCommentaires: (args: {
    data: CommentaireUpdateManyMutationInput;
    where?: CommentaireWhereInput;
  }) => BatchPayloadPromise;
  upsertCommentaire: (args: {
    where: CommentaireWhereUniqueInput;
    create: CommentaireCreateInput;
    update: CommentaireUpdateInput;
  }) => CommentairePromise;
  deleteCommentaire: (where: CommentaireWhereUniqueInput) => CommentairePromise;
  deleteManyCommentaires: (
    where?: CommentaireWhereInput
  ) => BatchPayloadPromise;
  createEmprunts: (data: EmpruntsCreateInput) => EmpruntsPromise;
  updateEmprunts: (args: {
    data: EmpruntsUpdateInput;
    where: EmpruntsWhereUniqueInput;
  }) => EmpruntsPromise;
  updateManyEmpruntses: (args: {
    data: EmpruntsUpdateManyMutationInput;
    where?: EmpruntsWhereInput;
  }) => BatchPayloadPromise;
  upsertEmprunts: (args: {
    where: EmpruntsWhereUniqueInput;
    create: EmpruntsCreateInput;
    update: EmpruntsUpdateInput;
  }) => EmpruntsPromise;
  deleteEmprunts: (where: EmpruntsWhereUniqueInput) => EmpruntsPromise;
  deleteManyEmpruntses: (where?: EmpruntsWhereInput) => BatchPayloadPromise;
  createLivre: (data: LivreCreateInput) => LivrePromise;
  updateLivre: (args: {
    data: LivreUpdateInput;
    where: LivreWhereUniqueInput;
  }) => LivrePromise;
  updateManyLivres: (args: {
    data: LivreUpdateManyMutationInput;
    where?: LivreWhereInput;
  }) => BatchPayloadPromise;
  upsertLivre: (args: {
    where: LivreWhereUniqueInput;
    create: LivreCreateInput;
    update: LivreUpdateInput;
  }) => LivrePromise;
  deleteLivre: (where: LivreWhereUniqueInput) => LivrePromise;
  deleteManyLivres: (where?: LivreWhereInput) => BatchPayloadPromise;
  createUtilisateur: (data: UtilisateurCreateInput) => UtilisateurPromise;
  updateUtilisateur: (args: {
    data: UtilisateurUpdateInput;
    where: UtilisateurWhereUniqueInput;
  }) => UtilisateurPromise;
  updateManyUtilisateurs: (args: {
    data: UtilisateurUpdateManyMutationInput;
    where?: UtilisateurWhereInput;
  }) => BatchPayloadPromise;
  upsertUtilisateur: (args: {
    where: UtilisateurWhereUniqueInput;
    create: UtilisateurCreateInput;
    update: UtilisateurUpdateInput;
  }) => UtilisateurPromise;
  deleteUtilisateur: (where: UtilisateurWhereUniqueInput) => UtilisateurPromise;
  deleteManyUtilisateurs: (
    where?: UtilisateurWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  commentaire: (
    where?: CommentaireSubscriptionWhereInput
  ) => CommentaireSubscriptionPayloadSubscription;
  emprunts: (
    where?: EmpruntsSubscriptionWhereInput
  ) => EmpruntsSubscriptionPayloadSubscription;
  livre: (
    where?: LivreSubscriptionWhereInput
  ) => LivreSubscriptionPayloadSubscription;
  utilisateur: (
    where?: UtilisateurSubscriptionWhereInput
  ) => UtilisateurSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CommentaireOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "message_ASC"
  | "message_DESC"
  | "eval_ASC"
  | "eval_DESC"
  | "utilite_ASC"
  | "utilite_DESC";

export type LivreOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "titre_ASC"
  | "titre_DESC"
  | "auteur_ASC"
  | "auteur_DESC"
  | "edition_ASC"
  | "edition_DESC"
  | "stock_ASC"
  | "stock_DESC";

export type EmpruntsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "dateRetour_ASC"
  | "dateRetour_DESC"
  | "dateSortie_ASC"
  | "dateSortie_DESC";

export type UtilisateurOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nom_ASC"
  | "nom_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CommentaireWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CommentaireWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  eval?: Maybe<Int>;
  eval_not?: Maybe<Int>;
  eval_in?: Maybe<Int[] | Int>;
  eval_not_in?: Maybe<Int[] | Int>;
  eval_lt?: Maybe<Int>;
  eval_lte?: Maybe<Int>;
  eval_gt?: Maybe<Int>;
  eval_gte?: Maybe<Int>;
  utilite?: Maybe<Int>;
  utilite_not?: Maybe<Int>;
  utilite_in?: Maybe<Int[] | Int>;
  utilite_not_in?: Maybe<Int[] | Int>;
  utilite_lt?: Maybe<Int>;
  utilite_lte?: Maybe<Int>;
  utilite_gt?: Maybe<Int>;
  utilite_gte?: Maybe<Int>;
  AND?: Maybe<CommentaireWhereInput[] | CommentaireWhereInput>;
}

export type EmpruntsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LivreWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  titre?: Maybe<String>;
  titre_not?: Maybe<String>;
  titre_in?: Maybe<String[] | String>;
  titre_not_in?: Maybe<String[] | String>;
  titre_lt?: Maybe<String>;
  titre_lte?: Maybe<String>;
  titre_gt?: Maybe<String>;
  titre_gte?: Maybe<String>;
  titre_contains?: Maybe<String>;
  titre_not_contains?: Maybe<String>;
  titre_starts_with?: Maybe<String>;
  titre_not_starts_with?: Maybe<String>;
  titre_ends_with?: Maybe<String>;
  titre_not_ends_with?: Maybe<String>;
  auteur?: Maybe<String>;
  auteur_not?: Maybe<String>;
  auteur_in?: Maybe<String[] | String>;
  auteur_not_in?: Maybe<String[] | String>;
  auteur_lt?: Maybe<String>;
  auteur_lte?: Maybe<String>;
  auteur_gt?: Maybe<String>;
  auteur_gte?: Maybe<String>;
  auteur_contains?: Maybe<String>;
  auteur_not_contains?: Maybe<String>;
  auteur_starts_with?: Maybe<String>;
  auteur_not_starts_with?: Maybe<String>;
  auteur_ends_with?: Maybe<String>;
  auteur_not_ends_with?: Maybe<String>;
  edition?: Maybe<String>;
  edition_not?: Maybe<String>;
  edition_in?: Maybe<String[] | String>;
  edition_not_in?: Maybe<String[] | String>;
  edition_lt?: Maybe<String>;
  edition_lte?: Maybe<String>;
  edition_gt?: Maybe<String>;
  edition_gte?: Maybe<String>;
  edition_contains?: Maybe<String>;
  edition_not_contains?: Maybe<String>;
  edition_starts_with?: Maybe<String>;
  edition_not_starts_with?: Maybe<String>;
  edition_ends_with?: Maybe<String>;
  edition_not_ends_with?: Maybe<String>;
  stock?: Maybe<Int>;
  stock_not?: Maybe<Int>;
  stock_in?: Maybe<Int[] | Int>;
  stock_not_in?: Maybe<Int[] | Int>;
  stock_lt?: Maybe<Int>;
  stock_lte?: Maybe<Int>;
  stock_gt?: Maybe<Int>;
  stock_gte?: Maybe<Int>;
  commentaire_some?: Maybe<CommentaireWhereInput>;
  AND?: Maybe<LivreWhereInput[] | LivreWhereInput>;
}

export interface EmpruntsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  titre_some?: Maybe<LivreWhereInput>;
  dateRetour?: Maybe<String>;
  dateRetour_not?: Maybe<String>;
  dateRetour_in?: Maybe<String[] | String>;
  dateRetour_not_in?: Maybe<String[] | String>;
  dateRetour_lt?: Maybe<String>;
  dateRetour_lte?: Maybe<String>;
  dateRetour_gt?: Maybe<String>;
  dateRetour_gte?: Maybe<String>;
  dateRetour_contains?: Maybe<String>;
  dateRetour_not_contains?: Maybe<String>;
  dateRetour_starts_with?: Maybe<String>;
  dateRetour_not_starts_with?: Maybe<String>;
  dateRetour_ends_with?: Maybe<String>;
  dateRetour_not_ends_with?: Maybe<String>;
  dateSortie?: Maybe<String>;
  dateSortie_not?: Maybe<String>;
  dateSortie_in?: Maybe<String[] | String>;
  dateSortie_not_in?: Maybe<String[] | String>;
  dateSortie_lt?: Maybe<String>;
  dateSortie_lte?: Maybe<String>;
  dateSortie_gt?: Maybe<String>;
  dateSortie_gte?: Maybe<String>;
  dateSortie_contains?: Maybe<String>;
  dateSortie_not_contains?: Maybe<String>;
  dateSortie_starts_with?: Maybe<String>;
  dateSortie_not_starts_with?: Maybe<String>;
  dateSortie_ends_with?: Maybe<String>;
  dateSortie_not_ends_with?: Maybe<String>;
  AND?: Maybe<EmpruntsWhereInput[] | EmpruntsWhereInput>;
}

export type LivreWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UtilisateurWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UtilisateurWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  nom?: Maybe<String>;
  nom_not?: Maybe<String>;
  nom_in?: Maybe<String[] | String>;
  nom_not_in?: Maybe<String[] | String>;
  nom_lt?: Maybe<String>;
  nom_lte?: Maybe<String>;
  nom_gt?: Maybe<String>;
  nom_gte?: Maybe<String>;
  nom_contains?: Maybe<String>;
  nom_not_contains?: Maybe<String>;
  nom_starts_with?: Maybe<String>;
  nom_not_starts_with?: Maybe<String>;
  nom_ends_with?: Maybe<String>;
  nom_not_ends_with?: Maybe<String>;
  emprunts_some?: Maybe<EmpruntsWhereInput>;
  commentaire_some?: Maybe<CommentaireWhereInput>;
  AND?: Maybe<UtilisateurWhereInput[] | UtilisateurWhereInput>;
}

export interface CommentaireCreateInput {
  id?: Maybe<ID_Input>;
  message: String;
  eval?: Maybe<Int>;
  utilite?: Maybe<Int>;
}

export interface CommentaireUpdateInput {
  message?: Maybe<String>;
  eval?: Maybe<Int>;
  utilite?: Maybe<Int>;
}

export interface CommentaireUpdateManyMutationInput {
  message?: Maybe<String>;
  eval?: Maybe<Int>;
  utilite?: Maybe<Int>;
}

export interface EmpruntsCreateInput {
  id?: Maybe<ID_Input>;
  titre?: Maybe<LivreCreateManyInput>;
  dateRetour: String;
  dateSortie: String;
}

export interface LivreCreateManyInput {
  create?: Maybe<LivreCreateInput[] | LivreCreateInput>;
  connect?: Maybe<LivreWhereUniqueInput[] | LivreWhereUniqueInput>;
}

export interface LivreCreateInput {
  id?: Maybe<ID_Input>;
  titre?: Maybe<String>;
  auteur?: Maybe<String>;
  edition?: Maybe<String>;
  stock?: Maybe<Int>;
  commentaire?: Maybe<CommentaireCreateManyInput>;
}

export interface CommentaireCreateManyInput {
  create?: Maybe<CommentaireCreateInput[] | CommentaireCreateInput>;
  connect?: Maybe<CommentaireWhereUniqueInput[] | CommentaireWhereUniqueInput>;
}

export interface EmpruntsUpdateInput {
  titre?: Maybe<LivreUpdateManyInput>;
  dateRetour?: Maybe<String>;
  dateSortie?: Maybe<String>;
}

export interface LivreUpdateManyInput {
  create?: Maybe<LivreCreateInput[] | LivreCreateInput>;
  update?: Maybe<
    | LivreUpdateWithWhereUniqueNestedInput[]
    | LivreUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | LivreUpsertWithWhereUniqueNestedInput[]
    | LivreUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<LivreWhereUniqueInput[] | LivreWhereUniqueInput>;
  connect?: Maybe<LivreWhereUniqueInput[] | LivreWhereUniqueInput>;
  set?: Maybe<LivreWhereUniqueInput[] | LivreWhereUniqueInput>;
  disconnect?: Maybe<LivreWhereUniqueInput[] | LivreWhereUniqueInput>;
  deleteMany?: Maybe<LivreScalarWhereInput[] | LivreScalarWhereInput>;
  updateMany?: Maybe<
    LivreUpdateManyWithWhereNestedInput[] | LivreUpdateManyWithWhereNestedInput
  >;
}

export interface LivreUpdateWithWhereUniqueNestedInput {
  where: LivreWhereUniqueInput;
  data: LivreUpdateDataInput;
}

export interface LivreUpdateDataInput {
  titre?: Maybe<String>;
  auteur?: Maybe<String>;
  edition?: Maybe<String>;
  stock?: Maybe<Int>;
  commentaire?: Maybe<CommentaireUpdateManyInput>;
}

export interface CommentaireUpdateManyInput {
  create?: Maybe<CommentaireCreateInput[] | CommentaireCreateInput>;
  update?: Maybe<
    | CommentaireUpdateWithWhereUniqueNestedInput[]
    | CommentaireUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | CommentaireUpsertWithWhereUniqueNestedInput[]
    | CommentaireUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<CommentaireWhereUniqueInput[] | CommentaireWhereUniqueInput>;
  connect?: Maybe<CommentaireWhereUniqueInput[] | CommentaireWhereUniqueInput>;
  set?: Maybe<CommentaireWhereUniqueInput[] | CommentaireWhereUniqueInput>;
  disconnect?: Maybe<
    CommentaireWhereUniqueInput[] | CommentaireWhereUniqueInput
  >;
  deleteMany?: Maybe<
    CommentaireScalarWhereInput[] | CommentaireScalarWhereInput
  >;
  updateMany?: Maybe<
    | CommentaireUpdateManyWithWhereNestedInput[]
    | CommentaireUpdateManyWithWhereNestedInput
  >;
}

export interface CommentaireUpdateWithWhereUniqueNestedInput {
  where: CommentaireWhereUniqueInput;
  data: CommentaireUpdateDataInput;
}

export interface CommentaireUpdateDataInput {
  message?: Maybe<String>;
  eval?: Maybe<Int>;
  utilite?: Maybe<Int>;
}

export interface CommentaireUpsertWithWhereUniqueNestedInput {
  where: CommentaireWhereUniqueInput;
  update: CommentaireUpdateDataInput;
  create: CommentaireCreateInput;
}

export interface CommentaireScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  eval?: Maybe<Int>;
  eval_not?: Maybe<Int>;
  eval_in?: Maybe<Int[] | Int>;
  eval_not_in?: Maybe<Int[] | Int>;
  eval_lt?: Maybe<Int>;
  eval_lte?: Maybe<Int>;
  eval_gt?: Maybe<Int>;
  eval_gte?: Maybe<Int>;
  utilite?: Maybe<Int>;
  utilite_not?: Maybe<Int>;
  utilite_in?: Maybe<Int[] | Int>;
  utilite_not_in?: Maybe<Int[] | Int>;
  utilite_lt?: Maybe<Int>;
  utilite_lte?: Maybe<Int>;
  utilite_gt?: Maybe<Int>;
  utilite_gte?: Maybe<Int>;
  AND?: Maybe<CommentaireScalarWhereInput[] | CommentaireScalarWhereInput>;
  OR?: Maybe<CommentaireScalarWhereInput[] | CommentaireScalarWhereInput>;
  NOT?: Maybe<CommentaireScalarWhereInput[] | CommentaireScalarWhereInput>;
}

export interface CommentaireUpdateManyWithWhereNestedInput {
  where: CommentaireScalarWhereInput;
  data: CommentaireUpdateManyDataInput;
}

export interface CommentaireUpdateManyDataInput {
  message?: Maybe<String>;
  eval?: Maybe<Int>;
  utilite?: Maybe<Int>;
}

export interface LivreUpsertWithWhereUniqueNestedInput {
  where: LivreWhereUniqueInput;
  update: LivreUpdateDataInput;
  create: LivreCreateInput;
}

export interface LivreScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  titre?: Maybe<String>;
  titre_not?: Maybe<String>;
  titre_in?: Maybe<String[] | String>;
  titre_not_in?: Maybe<String[] | String>;
  titre_lt?: Maybe<String>;
  titre_lte?: Maybe<String>;
  titre_gt?: Maybe<String>;
  titre_gte?: Maybe<String>;
  titre_contains?: Maybe<String>;
  titre_not_contains?: Maybe<String>;
  titre_starts_with?: Maybe<String>;
  titre_not_starts_with?: Maybe<String>;
  titre_ends_with?: Maybe<String>;
  titre_not_ends_with?: Maybe<String>;
  auteur?: Maybe<String>;
  auteur_not?: Maybe<String>;
  auteur_in?: Maybe<String[] | String>;
  auteur_not_in?: Maybe<String[] | String>;
  auteur_lt?: Maybe<String>;
  auteur_lte?: Maybe<String>;
  auteur_gt?: Maybe<String>;
  auteur_gte?: Maybe<String>;
  auteur_contains?: Maybe<String>;
  auteur_not_contains?: Maybe<String>;
  auteur_starts_with?: Maybe<String>;
  auteur_not_starts_with?: Maybe<String>;
  auteur_ends_with?: Maybe<String>;
  auteur_not_ends_with?: Maybe<String>;
  edition?: Maybe<String>;
  edition_not?: Maybe<String>;
  edition_in?: Maybe<String[] | String>;
  edition_not_in?: Maybe<String[] | String>;
  edition_lt?: Maybe<String>;
  edition_lte?: Maybe<String>;
  edition_gt?: Maybe<String>;
  edition_gte?: Maybe<String>;
  edition_contains?: Maybe<String>;
  edition_not_contains?: Maybe<String>;
  edition_starts_with?: Maybe<String>;
  edition_not_starts_with?: Maybe<String>;
  edition_ends_with?: Maybe<String>;
  edition_not_ends_with?: Maybe<String>;
  stock?: Maybe<Int>;
  stock_not?: Maybe<Int>;
  stock_in?: Maybe<Int[] | Int>;
  stock_not_in?: Maybe<Int[] | Int>;
  stock_lt?: Maybe<Int>;
  stock_lte?: Maybe<Int>;
  stock_gt?: Maybe<Int>;
  stock_gte?: Maybe<Int>;
  AND?: Maybe<LivreScalarWhereInput[] | LivreScalarWhereInput>;
  OR?: Maybe<LivreScalarWhereInput[] | LivreScalarWhereInput>;
  NOT?: Maybe<LivreScalarWhereInput[] | LivreScalarWhereInput>;
}

export interface LivreUpdateManyWithWhereNestedInput {
  where: LivreScalarWhereInput;
  data: LivreUpdateManyDataInput;
}

export interface LivreUpdateManyDataInput {
  titre?: Maybe<String>;
  auteur?: Maybe<String>;
  edition?: Maybe<String>;
  stock?: Maybe<Int>;
}

export interface EmpruntsUpdateManyMutationInput {
  dateRetour?: Maybe<String>;
  dateSortie?: Maybe<String>;
}

export interface LivreUpdateInput {
  titre?: Maybe<String>;
  auteur?: Maybe<String>;
  edition?: Maybe<String>;
  stock?: Maybe<Int>;
  commentaire?: Maybe<CommentaireUpdateManyInput>;
}

export interface LivreUpdateManyMutationInput {
  titre?: Maybe<String>;
  auteur?: Maybe<String>;
  edition?: Maybe<String>;
  stock?: Maybe<Int>;
}

export interface UtilisateurCreateInput {
  id?: Maybe<ID_Input>;
  nom: String;
  emprunts?: Maybe<EmpruntsCreateManyInput>;
  commentaire?: Maybe<CommentaireCreateManyInput>;
}

export interface EmpruntsCreateManyInput {
  create?: Maybe<EmpruntsCreateInput[] | EmpruntsCreateInput>;
  connect?: Maybe<EmpruntsWhereUniqueInput[] | EmpruntsWhereUniqueInput>;
}

export interface UtilisateurUpdateInput {
  nom?: Maybe<String>;
  emprunts?: Maybe<EmpruntsUpdateManyInput>;
  commentaire?: Maybe<CommentaireUpdateManyInput>;
}

export interface EmpruntsUpdateManyInput {
  create?: Maybe<EmpruntsCreateInput[] | EmpruntsCreateInput>;
  update?: Maybe<
    | EmpruntsUpdateWithWhereUniqueNestedInput[]
    | EmpruntsUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | EmpruntsUpsertWithWhereUniqueNestedInput[]
    | EmpruntsUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<EmpruntsWhereUniqueInput[] | EmpruntsWhereUniqueInput>;
  connect?: Maybe<EmpruntsWhereUniqueInput[] | EmpruntsWhereUniqueInput>;
  set?: Maybe<EmpruntsWhereUniqueInput[] | EmpruntsWhereUniqueInput>;
  disconnect?: Maybe<EmpruntsWhereUniqueInput[] | EmpruntsWhereUniqueInput>;
  deleteMany?: Maybe<EmpruntsScalarWhereInput[] | EmpruntsScalarWhereInput>;
  updateMany?: Maybe<
    | EmpruntsUpdateManyWithWhereNestedInput[]
    | EmpruntsUpdateManyWithWhereNestedInput
  >;
}

export interface EmpruntsUpdateWithWhereUniqueNestedInput {
  where: EmpruntsWhereUniqueInput;
  data: EmpruntsUpdateDataInput;
}

export interface EmpruntsUpdateDataInput {
  titre?: Maybe<LivreUpdateManyInput>;
  dateRetour?: Maybe<String>;
  dateSortie?: Maybe<String>;
}

export interface EmpruntsUpsertWithWhereUniqueNestedInput {
  where: EmpruntsWhereUniqueInput;
  update: EmpruntsUpdateDataInput;
  create: EmpruntsCreateInput;
}

export interface EmpruntsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  dateRetour?: Maybe<String>;
  dateRetour_not?: Maybe<String>;
  dateRetour_in?: Maybe<String[] | String>;
  dateRetour_not_in?: Maybe<String[] | String>;
  dateRetour_lt?: Maybe<String>;
  dateRetour_lte?: Maybe<String>;
  dateRetour_gt?: Maybe<String>;
  dateRetour_gte?: Maybe<String>;
  dateRetour_contains?: Maybe<String>;
  dateRetour_not_contains?: Maybe<String>;
  dateRetour_starts_with?: Maybe<String>;
  dateRetour_not_starts_with?: Maybe<String>;
  dateRetour_ends_with?: Maybe<String>;
  dateRetour_not_ends_with?: Maybe<String>;
  dateSortie?: Maybe<String>;
  dateSortie_not?: Maybe<String>;
  dateSortie_in?: Maybe<String[] | String>;
  dateSortie_not_in?: Maybe<String[] | String>;
  dateSortie_lt?: Maybe<String>;
  dateSortie_lte?: Maybe<String>;
  dateSortie_gt?: Maybe<String>;
  dateSortie_gte?: Maybe<String>;
  dateSortie_contains?: Maybe<String>;
  dateSortie_not_contains?: Maybe<String>;
  dateSortie_starts_with?: Maybe<String>;
  dateSortie_not_starts_with?: Maybe<String>;
  dateSortie_ends_with?: Maybe<String>;
  dateSortie_not_ends_with?: Maybe<String>;
  AND?: Maybe<EmpruntsScalarWhereInput[] | EmpruntsScalarWhereInput>;
  OR?: Maybe<EmpruntsScalarWhereInput[] | EmpruntsScalarWhereInput>;
  NOT?: Maybe<EmpruntsScalarWhereInput[] | EmpruntsScalarWhereInput>;
}

export interface EmpruntsUpdateManyWithWhereNestedInput {
  where: EmpruntsScalarWhereInput;
  data: EmpruntsUpdateManyDataInput;
}

export interface EmpruntsUpdateManyDataInput {
  dateRetour?: Maybe<String>;
  dateSortie?: Maybe<String>;
}

export interface UtilisateurUpdateManyMutationInput {
  nom?: Maybe<String>;
}

export interface CommentaireSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentaireWhereInput>;
  AND?: Maybe<
    CommentaireSubscriptionWhereInput[] | CommentaireSubscriptionWhereInput
  >;
}

export interface EmpruntsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmpruntsWhereInput>;
  AND?: Maybe<
    EmpruntsSubscriptionWhereInput[] | EmpruntsSubscriptionWhereInput
  >;
}

export interface LivreSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LivreWhereInput>;
  AND?: Maybe<LivreSubscriptionWhereInput[] | LivreSubscriptionWhereInput>;
}

export interface UtilisateurSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UtilisateurWhereInput>;
  AND?: Maybe<
    UtilisateurSubscriptionWhereInput[] | UtilisateurSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Commentaire {
  id: ID_Output;
  message: String;
  eval?: Int;
  utilite?: Int;
}

export interface CommentairePromise extends Promise<Commentaire>, Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
  eval: () => Promise<Int>;
  utilite: () => Promise<Int>;
}

export interface CommentaireSubscription
  extends Promise<AsyncIterator<Commentaire>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
  eval: () => Promise<AsyncIterator<Int>>;
  utilite: () => Promise<AsyncIterator<Int>>;
}

export interface CommentaireNullablePromise
  extends Promise<Commentaire | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
  eval: () => Promise<Int>;
  utilite: () => Promise<Int>;
}

export interface CommentaireConnection {
  pageInfo: PageInfo;
  edges: CommentaireEdge[];
}

export interface CommentaireConnectionPromise
  extends Promise<CommentaireConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentaireEdge>>() => T;
  aggregate: <T = AggregateCommentairePromise>() => T;
}

export interface CommentaireConnectionSubscription
  extends Promise<AsyncIterator<CommentaireConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentaireEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentaireSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentaireEdge {
  node: Commentaire;
  cursor: String;
}

export interface CommentaireEdgePromise
  extends Promise<CommentaireEdge>,
    Fragmentable {
  node: <T = CommentairePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentaireEdgeSubscription
  extends Promise<AsyncIterator<CommentaireEdge>>,
    Fragmentable {
  node: <T = CommentaireSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCommentaire {
  count: Int;
}

export interface AggregateCommentairePromise
  extends Promise<AggregateCommentaire>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentaireSubscription
  extends Promise<AsyncIterator<AggregateCommentaire>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Emprunts {
  id: ID_Output;
  dateRetour: String;
  dateSortie: String;
}

export interface EmpruntsPromise extends Promise<Emprunts>, Fragmentable {
  id: () => Promise<ID_Output>;
  titre: <T = FragmentableArray<Livre>>(args?: {
    where?: LivreWhereInput;
    orderBy?: LivreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dateRetour: () => Promise<String>;
  dateSortie: () => Promise<String>;
}

export interface EmpruntsSubscription
  extends Promise<AsyncIterator<Emprunts>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  titre: <T = Promise<AsyncIterator<LivreSubscription>>>(args?: {
    where?: LivreWhereInput;
    orderBy?: LivreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dateRetour: () => Promise<AsyncIterator<String>>;
  dateSortie: () => Promise<AsyncIterator<String>>;
}

export interface EmpruntsNullablePromise
  extends Promise<Emprunts | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  titre: <T = FragmentableArray<Livre>>(args?: {
    where?: LivreWhereInput;
    orderBy?: LivreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dateRetour: () => Promise<String>;
  dateSortie: () => Promise<String>;
}

export interface Livre {
  id: ID_Output;
  titre?: String;
  auteur?: String;
  edition?: String;
  stock?: Int;
}

export interface LivrePromise extends Promise<Livre>, Fragmentable {
  id: () => Promise<ID_Output>;
  titre: () => Promise<String>;
  auteur: () => Promise<String>;
  edition: () => Promise<String>;
  stock: () => Promise<Int>;
  commentaire: <T = FragmentableArray<Commentaire>>(args?: {
    where?: CommentaireWhereInput;
    orderBy?: CommentaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LivreSubscription
  extends Promise<AsyncIterator<Livre>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  titre: () => Promise<AsyncIterator<String>>;
  auteur: () => Promise<AsyncIterator<String>>;
  edition: () => Promise<AsyncIterator<String>>;
  stock: () => Promise<AsyncIterator<Int>>;
  commentaire: <T = Promise<AsyncIterator<CommentaireSubscription>>>(args?: {
    where?: CommentaireWhereInput;
    orderBy?: CommentaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LivreNullablePromise
  extends Promise<Livre | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  titre: () => Promise<String>;
  auteur: () => Promise<String>;
  edition: () => Promise<String>;
  stock: () => Promise<Int>;
  commentaire: <T = FragmentableArray<Commentaire>>(args?: {
    where?: CommentaireWhereInput;
    orderBy?: CommentaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EmpruntsConnection {
  pageInfo: PageInfo;
  edges: EmpruntsEdge[];
}

export interface EmpruntsConnectionPromise
  extends Promise<EmpruntsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmpruntsEdge>>() => T;
  aggregate: <T = AggregateEmpruntsPromise>() => T;
}

export interface EmpruntsConnectionSubscription
  extends Promise<AsyncIterator<EmpruntsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmpruntsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmpruntsSubscription>() => T;
}

export interface EmpruntsEdge {
  node: Emprunts;
  cursor: String;
}

export interface EmpruntsEdgePromise
  extends Promise<EmpruntsEdge>,
    Fragmentable {
  node: <T = EmpruntsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmpruntsEdgeSubscription
  extends Promise<AsyncIterator<EmpruntsEdge>>,
    Fragmentable {
  node: <T = EmpruntsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmprunts {
  count: Int;
}

export interface AggregateEmpruntsPromise
  extends Promise<AggregateEmprunts>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmpruntsSubscription
  extends Promise<AsyncIterator<AggregateEmprunts>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LivreConnection {
  pageInfo: PageInfo;
  edges: LivreEdge[];
}

export interface LivreConnectionPromise
  extends Promise<LivreConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LivreEdge>>() => T;
  aggregate: <T = AggregateLivrePromise>() => T;
}

export interface LivreConnectionSubscription
  extends Promise<AsyncIterator<LivreConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LivreEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLivreSubscription>() => T;
}

export interface LivreEdge {
  node: Livre;
  cursor: String;
}

export interface LivreEdgePromise extends Promise<LivreEdge>, Fragmentable {
  node: <T = LivrePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LivreEdgeSubscription
  extends Promise<AsyncIterator<LivreEdge>>,
    Fragmentable {
  node: <T = LivreSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLivre {
  count: Int;
}

export interface AggregateLivrePromise
  extends Promise<AggregateLivre>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLivreSubscription
  extends Promise<AsyncIterator<AggregateLivre>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Utilisateur {
  id: ID_Output;
  nom: String;
}

export interface UtilisateurPromise extends Promise<Utilisateur>, Fragmentable {
  id: () => Promise<ID_Output>;
  nom: () => Promise<String>;
  emprunts: <T = FragmentableArray<Emprunts>>(args?: {
    where?: EmpruntsWhereInput;
    orderBy?: EmpruntsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  commentaire: <T = FragmentableArray<Commentaire>>(args?: {
    where?: CommentaireWhereInput;
    orderBy?: CommentaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UtilisateurSubscription
  extends Promise<AsyncIterator<Utilisateur>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nom: () => Promise<AsyncIterator<String>>;
  emprunts: <T = Promise<AsyncIterator<EmpruntsSubscription>>>(args?: {
    where?: EmpruntsWhereInput;
    orderBy?: EmpruntsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  commentaire: <T = Promise<AsyncIterator<CommentaireSubscription>>>(args?: {
    where?: CommentaireWhereInput;
    orderBy?: CommentaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UtilisateurNullablePromise
  extends Promise<Utilisateur | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nom: () => Promise<String>;
  emprunts: <T = FragmentableArray<Emprunts>>(args?: {
    where?: EmpruntsWhereInput;
    orderBy?: EmpruntsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  commentaire: <T = FragmentableArray<Commentaire>>(args?: {
    where?: CommentaireWhereInput;
    orderBy?: CommentaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UtilisateurConnection {
  pageInfo: PageInfo;
  edges: UtilisateurEdge[];
}

export interface UtilisateurConnectionPromise
  extends Promise<UtilisateurConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UtilisateurEdge>>() => T;
  aggregate: <T = AggregateUtilisateurPromise>() => T;
}

export interface UtilisateurConnectionSubscription
  extends Promise<AsyncIterator<UtilisateurConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UtilisateurEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUtilisateurSubscription>() => T;
}

export interface UtilisateurEdge {
  node: Utilisateur;
  cursor: String;
}

export interface UtilisateurEdgePromise
  extends Promise<UtilisateurEdge>,
    Fragmentable {
  node: <T = UtilisateurPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UtilisateurEdgeSubscription
  extends Promise<AsyncIterator<UtilisateurEdge>>,
    Fragmentable {
  node: <T = UtilisateurSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUtilisateur {
  count: Int;
}

export interface AggregateUtilisateurPromise
  extends Promise<AggregateUtilisateur>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUtilisateurSubscription
  extends Promise<AsyncIterator<AggregateUtilisateur>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CommentaireSubscriptionPayload {
  mutation: MutationType;
  node: Commentaire;
  updatedFields: String[];
  previousValues: CommentairePreviousValues;
}

export interface CommentaireSubscriptionPayloadPromise
  extends Promise<CommentaireSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentairePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentairePreviousValuesPromise>() => T;
}

export interface CommentaireSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentaireSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentaireSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentairePreviousValuesSubscription>() => T;
}

export interface CommentairePreviousValues {
  id: ID_Output;
  message: String;
  eval?: Int;
  utilite?: Int;
}

export interface CommentairePreviousValuesPromise
  extends Promise<CommentairePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
  eval: () => Promise<Int>;
  utilite: () => Promise<Int>;
}

export interface CommentairePreviousValuesSubscription
  extends Promise<AsyncIterator<CommentairePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
  eval: () => Promise<AsyncIterator<Int>>;
  utilite: () => Promise<AsyncIterator<Int>>;
}

export interface EmpruntsSubscriptionPayload {
  mutation: MutationType;
  node: Emprunts;
  updatedFields: String[];
  previousValues: EmpruntsPreviousValues;
}

export interface EmpruntsSubscriptionPayloadPromise
  extends Promise<EmpruntsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmpruntsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmpruntsPreviousValuesPromise>() => T;
}

export interface EmpruntsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmpruntsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmpruntsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmpruntsPreviousValuesSubscription>() => T;
}

export interface EmpruntsPreviousValues {
  id: ID_Output;
  dateRetour: String;
  dateSortie: String;
}

export interface EmpruntsPreviousValuesPromise
  extends Promise<EmpruntsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateRetour: () => Promise<String>;
  dateSortie: () => Promise<String>;
}

export interface EmpruntsPreviousValuesSubscription
  extends Promise<AsyncIterator<EmpruntsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateRetour: () => Promise<AsyncIterator<String>>;
  dateSortie: () => Promise<AsyncIterator<String>>;
}

export interface LivreSubscriptionPayload {
  mutation: MutationType;
  node: Livre;
  updatedFields: String[];
  previousValues: LivrePreviousValues;
}

export interface LivreSubscriptionPayloadPromise
  extends Promise<LivreSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LivrePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LivrePreviousValuesPromise>() => T;
}

export interface LivreSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LivreSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LivreSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LivrePreviousValuesSubscription>() => T;
}

export interface LivrePreviousValues {
  id: ID_Output;
  titre?: String;
  auteur?: String;
  edition?: String;
  stock?: Int;
}

export interface LivrePreviousValuesPromise
  extends Promise<LivrePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  titre: () => Promise<String>;
  auteur: () => Promise<String>;
  edition: () => Promise<String>;
  stock: () => Promise<Int>;
}

export interface LivrePreviousValuesSubscription
  extends Promise<AsyncIterator<LivrePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  titre: () => Promise<AsyncIterator<String>>;
  auteur: () => Promise<AsyncIterator<String>>;
  edition: () => Promise<AsyncIterator<String>>;
  stock: () => Promise<AsyncIterator<Int>>;
}

export interface UtilisateurSubscriptionPayload {
  mutation: MutationType;
  node: Utilisateur;
  updatedFields: String[];
  previousValues: UtilisateurPreviousValues;
}

export interface UtilisateurSubscriptionPayloadPromise
  extends Promise<UtilisateurSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UtilisateurPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UtilisateurPreviousValuesPromise>() => T;
}

export interface UtilisateurSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UtilisateurSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UtilisateurSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UtilisateurPreviousValuesSubscription>() => T;
}

export interface UtilisateurPreviousValues {
  id: ID_Output;
  nom: String;
}

export interface UtilisateurPreviousValuesPromise
  extends Promise<UtilisateurPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nom: () => Promise<String>;
}

export interface UtilisateurPreviousValuesSubscription
  extends Promise<AsyncIterator<UtilisateurPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nom: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Utilisateur",
    embedded: false
  },
  {
    name: "Emprunts",
    embedded: false
  },
  {
    name: "Livre",
    embedded: false
  },
  {
    name: "Commentaire",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;

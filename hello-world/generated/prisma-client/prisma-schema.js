module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCommentaire {
  count: Int!
}

type AggregateEmprunts {
  count: Int!
}

type AggregateLivre {
  count: Int!
}

type AggregateUtilisateur {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Commentaire {
  id: ID!
  message: String!
  eval: Int
  utilite: Int
}

type CommentaireConnection {
  pageInfo: PageInfo!
  edges: [CommentaireEdge]!
  aggregate: AggregateCommentaire!
}

input CommentaireCreateInput {
  id: ID
  message: String!
  eval: Int
  utilite: Int
}

input CommentaireCreateManyInput {
  create: [CommentaireCreateInput!]
  connect: [CommentaireWhereUniqueInput!]
}

type CommentaireEdge {
  node: Commentaire!
  cursor: String!
}

enum CommentaireOrderByInput {
  id_ASC
  id_DESC
  message_ASC
  message_DESC
  eval_ASC
  eval_DESC
  utilite_ASC
  utilite_DESC
}

type CommentairePreviousValues {
  id: ID!
  message: String!
  eval: Int
  utilite: Int
}

input CommentaireScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  eval: Int
  eval_not: Int
  eval_in: [Int!]
  eval_not_in: [Int!]
  eval_lt: Int
  eval_lte: Int
  eval_gt: Int
  eval_gte: Int
  utilite: Int
  utilite_not: Int
  utilite_in: [Int!]
  utilite_not_in: [Int!]
  utilite_lt: Int
  utilite_lte: Int
  utilite_gt: Int
  utilite_gte: Int
  AND: [CommentaireScalarWhereInput!]
  OR: [CommentaireScalarWhereInput!]
  NOT: [CommentaireScalarWhereInput!]
}

type CommentaireSubscriptionPayload {
  mutation: MutationType!
  node: Commentaire
  updatedFields: [String!]
  previousValues: CommentairePreviousValues
}

input CommentaireSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentaireWhereInput
  AND: [CommentaireSubscriptionWhereInput!]
}

input CommentaireUpdateDataInput {
  message: String
  eval: Int
  utilite: Int
}

input CommentaireUpdateInput {
  message: String
  eval: Int
  utilite: Int
}

input CommentaireUpdateManyDataInput {
  message: String
  eval: Int
  utilite: Int
}

input CommentaireUpdateManyInput {
  create: [CommentaireCreateInput!]
  update: [CommentaireUpdateWithWhereUniqueNestedInput!]
  upsert: [CommentaireUpsertWithWhereUniqueNestedInput!]
  delete: [CommentaireWhereUniqueInput!]
  connect: [CommentaireWhereUniqueInput!]
  set: [CommentaireWhereUniqueInput!]
  disconnect: [CommentaireWhereUniqueInput!]
  deleteMany: [CommentaireScalarWhereInput!]
  updateMany: [CommentaireUpdateManyWithWhereNestedInput!]
}

input CommentaireUpdateManyMutationInput {
  message: String
  eval: Int
  utilite: Int
}

input CommentaireUpdateManyWithWhereNestedInput {
  where: CommentaireScalarWhereInput!
  data: CommentaireUpdateManyDataInput!
}

input CommentaireUpdateWithWhereUniqueNestedInput {
  where: CommentaireWhereUniqueInput!
  data: CommentaireUpdateDataInput!
}

input CommentaireUpsertWithWhereUniqueNestedInput {
  where: CommentaireWhereUniqueInput!
  update: CommentaireUpdateDataInput!
  create: CommentaireCreateInput!
}

input CommentaireWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  eval: Int
  eval_not: Int
  eval_in: [Int!]
  eval_not_in: [Int!]
  eval_lt: Int
  eval_lte: Int
  eval_gt: Int
  eval_gte: Int
  utilite: Int
  utilite_not: Int
  utilite_in: [Int!]
  utilite_not_in: [Int!]
  utilite_lt: Int
  utilite_lte: Int
  utilite_gt: Int
  utilite_gte: Int
  AND: [CommentaireWhereInput!]
}

input CommentaireWhereUniqueInput {
  id: ID
}

type Emprunts {
  id: ID!
  titre(where: LivreWhereInput, orderBy: LivreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Livre!]
  dateRetour: String!
  dateSortie: String!
}

type EmpruntsConnection {
  pageInfo: PageInfo!
  edges: [EmpruntsEdge]!
  aggregate: AggregateEmprunts!
}

input EmpruntsCreateInput {
  id: ID
  titre: LivreCreateManyInput
  dateRetour: String!
  dateSortie: String!
}

input EmpruntsCreateManyInput {
  create: [EmpruntsCreateInput!]
  connect: [EmpruntsWhereUniqueInput!]
}

type EmpruntsEdge {
  node: Emprunts!
  cursor: String!
}

enum EmpruntsOrderByInput {
  id_ASC
  id_DESC
  dateRetour_ASC
  dateRetour_DESC
  dateSortie_ASC
  dateSortie_DESC
}

type EmpruntsPreviousValues {
  id: ID!
  dateRetour: String!
  dateSortie: String!
}

input EmpruntsScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  dateRetour: String
  dateRetour_not: String
  dateRetour_in: [String!]
  dateRetour_not_in: [String!]
  dateRetour_lt: String
  dateRetour_lte: String
  dateRetour_gt: String
  dateRetour_gte: String
  dateRetour_contains: String
  dateRetour_not_contains: String
  dateRetour_starts_with: String
  dateRetour_not_starts_with: String
  dateRetour_ends_with: String
  dateRetour_not_ends_with: String
  dateSortie: String
  dateSortie_not: String
  dateSortie_in: [String!]
  dateSortie_not_in: [String!]
  dateSortie_lt: String
  dateSortie_lte: String
  dateSortie_gt: String
  dateSortie_gte: String
  dateSortie_contains: String
  dateSortie_not_contains: String
  dateSortie_starts_with: String
  dateSortie_not_starts_with: String
  dateSortie_ends_with: String
  dateSortie_not_ends_with: String
  AND: [EmpruntsScalarWhereInput!]
  OR: [EmpruntsScalarWhereInput!]
  NOT: [EmpruntsScalarWhereInput!]
}

type EmpruntsSubscriptionPayload {
  mutation: MutationType!
  node: Emprunts
  updatedFields: [String!]
  previousValues: EmpruntsPreviousValues
}

input EmpruntsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EmpruntsWhereInput
  AND: [EmpruntsSubscriptionWhereInput!]
}

input EmpruntsUpdateDataInput {
  titre: LivreUpdateManyInput
  dateRetour: String
  dateSortie: String
}

input EmpruntsUpdateInput {
  titre: LivreUpdateManyInput
  dateRetour: String
  dateSortie: String
}

input EmpruntsUpdateManyDataInput {
  dateRetour: String
  dateSortie: String
}

input EmpruntsUpdateManyInput {
  create: [EmpruntsCreateInput!]
  update: [EmpruntsUpdateWithWhereUniqueNestedInput!]
  upsert: [EmpruntsUpsertWithWhereUniqueNestedInput!]
  delete: [EmpruntsWhereUniqueInput!]
  connect: [EmpruntsWhereUniqueInput!]
  set: [EmpruntsWhereUniqueInput!]
  disconnect: [EmpruntsWhereUniqueInput!]
  deleteMany: [EmpruntsScalarWhereInput!]
  updateMany: [EmpruntsUpdateManyWithWhereNestedInput!]
}

input EmpruntsUpdateManyMutationInput {
  dateRetour: String
  dateSortie: String
}

input EmpruntsUpdateManyWithWhereNestedInput {
  where: EmpruntsScalarWhereInput!
  data: EmpruntsUpdateManyDataInput!
}

input EmpruntsUpdateWithWhereUniqueNestedInput {
  where: EmpruntsWhereUniqueInput!
  data: EmpruntsUpdateDataInput!
}

input EmpruntsUpsertWithWhereUniqueNestedInput {
  where: EmpruntsWhereUniqueInput!
  update: EmpruntsUpdateDataInput!
  create: EmpruntsCreateInput!
}

input EmpruntsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  titre_some: LivreWhereInput
  dateRetour: String
  dateRetour_not: String
  dateRetour_in: [String!]
  dateRetour_not_in: [String!]
  dateRetour_lt: String
  dateRetour_lte: String
  dateRetour_gt: String
  dateRetour_gte: String
  dateRetour_contains: String
  dateRetour_not_contains: String
  dateRetour_starts_with: String
  dateRetour_not_starts_with: String
  dateRetour_ends_with: String
  dateRetour_not_ends_with: String
  dateSortie: String
  dateSortie_not: String
  dateSortie_in: [String!]
  dateSortie_not_in: [String!]
  dateSortie_lt: String
  dateSortie_lte: String
  dateSortie_gt: String
  dateSortie_gte: String
  dateSortie_contains: String
  dateSortie_not_contains: String
  dateSortie_starts_with: String
  dateSortie_not_starts_with: String
  dateSortie_ends_with: String
  dateSortie_not_ends_with: String
  AND: [EmpruntsWhereInput!]
}

input EmpruntsWhereUniqueInput {
  id: ID
}

type Livre {
  id: ID!
  titre: String
  auteur: String
  edition: String
  stock: Int
  commentaire(where: CommentaireWhereInput, orderBy: CommentaireOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Commentaire!]
}

type LivreConnection {
  pageInfo: PageInfo!
  edges: [LivreEdge]!
  aggregate: AggregateLivre!
}

input LivreCreateInput {
  id: ID
  titre: String
  auteur: String
  edition: String
  stock: Int
  commentaire: CommentaireCreateManyInput
}

input LivreCreateManyInput {
  create: [LivreCreateInput!]
  connect: [LivreWhereUniqueInput!]
}

type LivreEdge {
  node: Livre!
  cursor: String!
}

enum LivreOrderByInput {
  id_ASC
  id_DESC
  titre_ASC
  titre_DESC
  auteur_ASC
  auteur_DESC
  edition_ASC
  edition_DESC
  stock_ASC
  stock_DESC
}

type LivrePreviousValues {
  id: ID!
  titre: String
  auteur: String
  edition: String
  stock: Int
}

input LivreScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  titre: String
  titre_not: String
  titre_in: [String!]
  titre_not_in: [String!]
  titre_lt: String
  titre_lte: String
  titre_gt: String
  titre_gte: String
  titre_contains: String
  titre_not_contains: String
  titre_starts_with: String
  titre_not_starts_with: String
  titre_ends_with: String
  titre_not_ends_with: String
  auteur: String
  auteur_not: String
  auteur_in: [String!]
  auteur_not_in: [String!]
  auteur_lt: String
  auteur_lte: String
  auteur_gt: String
  auteur_gte: String
  auteur_contains: String
  auteur_not_contains: String
  auteur_starts_with: String
  auteur_not_starts_with: String
  auteur_ends_with: String
  auteur_not_ends_with: String
  edition: String
  edition_not: String
  edition_in: [String!]
  edition_not_in: [String!]
  edition_lt: String
  edition_lte: String
  edition_gt: String
  edition_gte: String
  edition_contains: String
  edition_not_contains: String
  edition_starts_with: String
  edition_not_starts_with: String
  edition_ends_with: String
  edition_not_ends_with: String
  stock: Int
  stock_not: Int
  stock_in: [Int!]
  stock_not_in: [Int!]
  stock_lt: Int
  stock_lte: Int
  stock_gt: Int
  stock_gte: Int
  AND: [LivreScalarWhereInput!]
  OR: [LivreScalarWhereInput!]
  NOT: [LivreScalarWhereInput!]
}

type LivreSubscriptionPayload {
  mutation: MutationType!
  node: Livre
  updatedFields: [String!]
  previousValues: LivrePreviousValues
}

input LivreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LivreWhereInput
  AND: [LivreSubscriptionWhereInput!]
}

input LivreUpdateDataInput {
  titre: String
  auteur: String
  edition: String
  stock: Int
  commentaire: CommentaireUpdateManyInput
}

input LivreUpdateInput {
  titre: String
  auteur: String
  edition: String
  stock: Int
  commentaire: CommentaireUpdateManyInput
}

input LivreUpdateManyDataInput {
  titre: String
  auteur: String
  edition: String
  stock: Int
}

input LivreUpdateManyInput {
  create: [LivreCreateInput!]
  update: [LivreUpdateWithWhereUniqueNestedInput!]
  upsert: [LivreUpsertWithWhereUniqueNestedInput!]
  delete: [LivreWhereUniqueInput!]
  connect: [LivreWhereUniqueInput!]
  set: [LivreWhereUniqueInput!]
  disconnect: [LivreWhereUniqueInput!]
  deleteMany: [LivreScalarWhereInput!]
  updateMany: [LivreUpdateManyWithWhereNestedInput!]
}

input LivreUpdateManyMutationInput {
  titre: String
  auteur: String
  edition: String
  stock: Int
}

input LivreUpdateManyWithWhereNestedInput {
  where: LivreScalarWhereInput!
  data: LivreUpdateManyDataInput!
}

input LivreUpdateWithWhereUniqueNestedInput {
  where: LivreWhereUniqueInput!
  data: LivreUpdateDataInput!
}

input LivreUpsertWithWhereUniqueNestedInput {
  where: LivreWhereUniqueInput!
  update: LivreUpdateDataInput!
  create: LivreCreateInput!
}

input LivreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  titre: String
  titre_not: String
  titre_in: [String!]
  titre_not_in: [String!]
  titre_lt: String
  titre_lte: String
  titre_gt: String
  titre_gte: String
  titre_contains: String
  titre_not_contains: String
  titre_starts_with: String
  titre_not_starts_with: String
  titre_ends_with: String
  titre_not_ends_with: String
  auteur: String
  auteur_not: String
  auteur_in: [String!]
  auteur_not_in: [String!]
  auteur_lt: String
  auteur_lte: String
  auteur_gt: String
  auteur_gte: String
  auteur_contains: String
  auteur_not_contains: String
  auteur_starts_with: String
  auteur_not_starts_with: String
  auteur_ends_with: String
  auteur_not_ends_with: String
  edition: String
  edition_not: String
  edition_in: [String!]
  edition_not_in: [String!]
  edition_lt: String
  edition_lte: String
  edition_gt: String
  edition_gte: String
  edition_contains: String
  edition_not_contains: String
  edition_starts_with: String
  edition_not_starts_with: String
  edition_ends_with: String
  edition_not_ends_with: String
  stock: Int
  stock_not: Int
  stock_in: [Int!]
  stock_not_in: [Int!]
  stock_lt: Int
  stock_lte: Int
  stock_gt: Int
  stock_gte: Int
  commentaire_some: CommentaireWhereInput
  AND: [LivreWhereInput!]
}

input LivreWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createCommentaire(data: CommentaireCreateInput!): Commentaire!
  updateCommentaire(data: CommentaireUpdateInput!, where: CommentaireWhereUniqueInput!): Commentaire
  updateManyCommentaires(data: CommentaireUpdateManyMutationInput!, where: CommentaireWhereInput): BatchPayload!
  upsertCommentaire(where: CommentaireWhereUniqueInput!, create: CommentaireCreateInput!, update: CommentaireUpdateInput!): Commentaire!
  deleteCommentaire(where: CommentaireWhereUniqueInput!): Commentaire
  deleteManyCommentaires(where: CommentaireWhereInput): BatchPayload!
  createEmprunts(data: EmpruntsCreateInput!): Emprunts!
  updateEmprunts(data: EmpruntsUpdateInput!, where: EmpruntsWhereUniqueInput!): Emprunts
  updateManyEmpruntses(data: EmpruntsUpdateManyMutationInput!, where: EmpruntsWhereInput): BatchPayload!
  upsertEmprunts(where: EmpruntsWhereUniqueInput!, create: EmpruntsCreateInput!, update: EmpruntsUpdateInput!): Emprunts!
  deleteEmprunts(where: EmpruntsWhereUniqueInput!): Emprunts
  deleteManyEmpruntses(where: EmpruntsWhereInput): BatchPayload!
  createLivre(data: LivreCreateInput!): Livre!
  updateLivre(data: LivreUpdateInput!, where: LivreWhereUniqueInput!): Livre
  updateManyLivres(data: LivreUpdateManyMutationInput!, where: LivreWhereInput): BatchPayload!
  upsertLivre(where: LivreWhereUniqueInput!, create: LivreCreateInput!, update: LivreUpdateInput!): Livre!
  deleteLivre(where: LivreWhereUniqueInput!): Livre
  deleteManyLivres(where: LivreWhereInput): BatchPayload!
  createUtilisateur(data: UtilisateurCreateInput!): Utilisateur!
  updateUtilisateur(data: UtilisateurUpdateInput!, where: UtilisateurWhereUniqueInput!): Utilisateur
  updateManyUtilisateurs(data: UtilisateurUpdateManyMutationInput!, where: UtilisateurWhereInput): BatchPayload!
  upsertUtilisateur(where: UtilisateurWhereUniqueInput!, create: UtilisateurCreateInput!, update: UtilisateurUpdateInput!): Utilisateur!
  deleteUtilisateur(where: UtilisateurWhereUniqueInput!): Utilisateur
  deleteManyUtilisateurs(where: UtilisateurWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  commentaire(where: CommentaireWhereUniqueInput!): Commentaire
  commentaires(where: CommentaireWhereInput, orderBy: CommentaireOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Commentaire]!
  commentairesConnection(where: CommentaireWhereInput, orderBy: CommentaireOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentaireConnection!
  emprunts(where: EmpruntsWhereUniqueInput!): Emprunts
  empruntses(where: EmpruntsWhereInput, orderBy: EmpruntsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Emprunts]!
  empruntsesConnection(where: EmpruntsWhereInput, orderBy: EmpruntsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EmpruntsConnection!
  livre(where: LivreWhereUniqueInput!): Livre
  livres(where: LivreWhereInput, orderBy: LivreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Livre]!
  livresConnection(where: LivreWhereInput, orderBy: LivreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LivreConnection!
  utilisateur(where: UtilisateurWhereUniqueInput!): Utilisateur
  utilisateurs(where: UtilisateurWhereInput, orderBy: UtilisateurOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Utilisateur]!
  utilisateursConnection(where: UtilisateurWhereInput, orderBy: UtilisateurOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UtilisateurConnection!
  node(id: ID!): Node
}

type Subscription {
  commentaire(where: CommentaireSubscriptionWhereInput): CommentaireSubscriptionPayload
  emprunts(where: EmpruntsSubscriptionWhereInput): EmpruntsSubscriptionPayload
  livre(where: LivreSubscriptionWhereInput): LivreSubscriptionPayload
  utilisateur(where: UtilisateurSubscriptionWhereInput): UtilisateurSubscriptionPayload
}

type Utilisateur {
  id: ID!
  nom: String!
  emprunts(where: EmpruntsWhereInput, orderBy: EmpruntsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Emprunts!]
  commentaire(where: CommentaireWhereInput, orderBy: CommentaireOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Commentaire!]
}

type UtilisateurConnection {
  pageInfo: PageInfo!
  edges: [UtilisateurEdge]!
  aggregate: AggregateUtilisateur!
}

input UtilisateurCreateInput {
  id: ID
  nom: String!
  emprunts: EmpruntsCreateManyInput
  commentaire: CommentaireCreateManyInput
}

type UtilisateurEdge {
  node: Utilisateur!
  cursor: String!
}

enum UtilisateurOrderByInput {
  id_ASC
  id_DESC
  nom_ASC
  nom_DESC
}

type UtilisateurPreviousValues {
  id: ID!
  nom: String!
}

type UtilisateurSubscriptionPayload {
  mutation: MutationType!
  node: Utilisateur
  updatedFields: [String!]
  previousValues: UtilisateurPreviousValues
}

input UtilisateurSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UtilisateurWhereInput
  AND: [UtilisateurSubscriptionWhereInput!]
}

input UtilisateurUpdateInput {
  nom: String
  emprunts: EmpruntsUpdateManyInput
  commentaire: CommentaireUpdateManyInput
}

input UtilisateurUpdateManyMutationInput {
  nom: String
}

input UtilisateurWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  nom: String
  nom_not: String
  nom_in: [String!]
  nom_not_in: [String!]
  nom_lt: String
  nom_lte: String
  nom_gt: String
  nom_gte: String
  nom_contains: String
  nom_not_contains: String
  nom_starts_with: String
  nom_not_starts_with: String
  nom_ends_with: String
  nom_not_ends_with: String
  emprunts_some: EmpruntsWhereInput
  commentaire_some: CommentaireWhereInput
  AND: [UtilisateurWhereInput!]
}

input UtilisateurWhereUniqueInput {
  id: ID
}
`
      }
    